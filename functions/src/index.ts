import { onSchedule } from 'firebase-functions/v2/scheduler'
import * as logger from 'firebase-functions/logger'
import { initializeApp } from 'firebase-admin/app'
import { getFirestore, Timestamp } from 'firebase-admin/firestore'
import OpenAI from 'openai'
import { OPENAI_API_KEY } from './secrets'
import { fetchImageByKeyword, UNSPLASH_ACCESS_KEY } from './unsplash'
import { postLatestToBuffer } from './buffer'

initializeApp()
const db = getFirestore()

export const scheduledAutoPost = onSchedule(
  {
    schedule: 'every day 09:00',
    secrets: [OPENAI_API_KEY, UNSPLASH_ACCESS_KEY],
  },
  async () => {
    logger.info('📅 自動投稿スケジュール実行開始')

    const todayDay = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'][
      new Date().getDay()
    ]
    /**
     * Firestoreから曜日と最近の使用履歴を考慮して、使用可能なランダムなキーワードを返す
     */
    async function getRandomKeyword(): Promise<string | null> {
      const keywordSnap = await db
        .collection('keywords')
        .where('active', '==', true)
        .get()

      if (keywordSnap.empty) {
        logger.warn('⚠️ キーワード候補が見つかりません')
        return null
      }

      const allKeywords = keywordSnap.docs
        .map((doc) => doc.data())
        .filter((k) => !k.days || k.days.includes(todayDay))

      const sevenDaysAgo = Timestamp.fromDate(
        new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
      )
      const recentSnap = await db
        .collection('posts')
        .where('createdAt', '>=', sevenDaysAgo)
        .where('autoGenerated', '==', true)
        .get()

      const recentKeywords = new Set<string>()
      recentSnap.docs.forEach((doc) => {
        const data = doc.data()
        if (data?.keyword) {
          recentKeywords.add(data.keyword)
        }
      })

      const filtered = allKeywords.filter((k) => !recentKeywords.has(k.keyword))
      if (filtered.length === 0) {
        logger.warn('⚠️ 使用可能なキーワードがありません（最近使用済み）')
        return null
      }

      const randomIndex = Math.floor(Math.random() * filtered.length)
      return filtered[randomIndex].keyword
    }

    const openai = new OpenAI({
      apiKey: OPENAI_API_KEY.value(),
    })

    const keyword = await getRandomKeyword()
    if (!keyword) return

    const prompt = `
【キャラクター設定】
あなたは38歳の営業職、共働きで子どもが2人いるという設定の「共感キャラクター」です。
読者と同じ目線・等身大の語り口で、自分の体験を語りながら文章を綴ってください。

【ブログ記事の出力構造】
以下の形式で出力してください（順番厳守・ラベル厳守）：

■ タイトル  
読者の心に引っかかる自然なタイトルをつけてください

■ カテゴリ  
副業／プログラミング学習／体験談／スクール選び など適切なカテゴリを1つ

■ 本文（Markdown）  
見出し（##）、リスト、改行を使って読みやすく書いてください。  
導入は感情・共感から入り、不安や悩み → 試行錯誤 → 気づき → 軽いリンク誘導 の流れで構成してください。

■ サムネ画像キーワード  
英単語3つをカンマ区切りで。記事の雰囲気・感情を反映（例: night, home, quiet）

■ タグ  
副業, プログラミング, 子育て, 体験談, 未経験 など3〜5個（カンマ区切り）

■ 推奨内部リンク  
下記から最大3つ選び、スラッグ形式で出力してください：
/comparison  
/blog/choose-programming-school-5-tips  
/blog/sidejob-success-programming-school  
/blog/check-before-apply-programming-school  
/blog/school-failures-and-how-to-avoid  
/blog/programming-beginner-complete-guide

【キーワード】
${keyword}

この形式に**必ず**従ってください。
    `

    const response = await openai.chat.completions.create({
      model: 'gpt-4',
      temperature: 0.7,
      messages: [
        {
          role: 'system',
          content:
            'あなたは共感を大切にする日本語のブログライターです。SEOにも強く、Markdown形式で記事を書きます。',
        },
        {
          role: 'user',
          content: prompt,
        },
      ],
    })

    const raw = response.choices[0]?.message.content ?? ''
    logger.info('🧾 OpenAI生成結果:', raw)

    const pattern =
      '■ タイトル\\s*(.+?)\\n+' +
      '■ カテゴリ\\s*(.+?)\\n+' +
      '■ 本文（Markdown）\\s*([\\s\\S]+?)\\n+' +
      '■ サムネ画像キーワード\\s*(.+?)\\n+' +
      '■ タグ\\s*([\\s\\S]+?)\\n+' +
      '■ 推奨内部リンク\\s*([\\s\\S]+)$'

    const match = raw.match(new RegExp(pattern, 'i'))
    if (!match) {
      logger.error('⚠️ OpenAI出力の形式に誤りがあります')
      return
    }

    const [, title, category, body, thumbnailKeywords, tagsRaw, linksRaw] =
      match

    const tags = tagsRaw
      .split(/,|\n|・|・/)
      .map((t) => t.trim())
      .filter(Boolean)

    const internalLinks = linksRaw
      .split(/\s|\n/)
      .map((l) => l.trim())
      .filter((l) => l.startsWith('/'))

    const now = new Date()
    const scheduled = new Date(now.getTime() + 24 * 60 * 60 * 1000)

    const image = await fetchImageByKeyword(thumbnailKeywords.trim())
    if (!image) {
      logger.warn('⚠️ サムネ画像が取得できなかったため、空で保存します')
    }

    const post = {
      title: title.trim(),
      body: body.trim(),
      category: category.trim(),
      slug: generateSlug(title),
      tags,
      internalLinks,
      keyword,
      thumbnailUrl: image?.url ?? '',
      thumbnailAttribution: {
        photographer: image?.photographer ?? '',
        photographer_url: image?.photographer_url ?? '',
      },
      autoGenerated: true,
      variantId: 'A',
      testTarget: ['title'],
      clickCount: 0,
      readCount: 0,
      createdAt: Timestamp.fromDate(now),
      publishedAt: Timestamp.fromDate(scheduled),
    }

    await db.collection('posts').add(post)
    logger.info(`✅ 自動投稿成功: ${post.title}`)
  }
)

// 🔁 ←ここで scheduledAutoPost 関数終了！カッコの位置に注意！

// ✅ こっちは完全に別の関数として独立させる
export const scheduledPostToBuffer = onSchedule(
  {
    schedule: 'every day 09:10', // ブログ投稿のあとに実行
    secrets: ['BUFFER_ACCESS_TOKEN', 'BUFFER_PROFILE_ID'],
  },
  async () => {
    await postLatestToBuffer()
  }
)

/**
 * タイトルからスラッグ（URL用文字列）を生成する
 * @param {string} title ブログ記事のタイトル
 * @return {string} スラッグ化された文字列（英数字・ハイフン）
 */
function generateSlug(title: string): string {
  return title
    .toLowerCase()
    .replace(/[^\w\s-]/g, '')
    .replace(/\s+/g, '-')
}
